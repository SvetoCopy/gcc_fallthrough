<h1>GCC Modify by Ruzal</h1>

<h2>Проблема</h2>
<p>Представим, что у нас есть какая-то non-void функция foo(int c), которая не во всех случаях возвращает значение. Например, в данном коде не возвращается значение при с != 0:</p>

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/a686eca5-fb5b-41e6-b020-147c1d69b750)

<p>Скомпилируем программу с различными флагами и посмотрим, что выводится в stderr:</p>

```
-O0 -fpic
```

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/6b294a9c-59ed-4c9f-99f6-7f02b8dbc414)


```
-O3 -fpic
```

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/c6dd8826-fb72-4aee-bba6-311e1827d458)

```
-O1 -fpic
```

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/d21cb189-c1a1-4d9a-9b01-333a20d4f8ec)

<p>Таким образом, мы видим undefined behaviour (далее UB) при различных флагах оптимизации.</p>

<h2>Цель</h2>
<p>Избавиться от UB и предложить однозначное решение для такого случая при всех флагах оптимизации.</p>

<h2>Пути решения проблемы</h2>
<li>Запретить компилировать программу с функцией, которая возвращает значение не при всех возможных случаях.</li>
<li>Заставить компилятор принудительно вставлять возврат значения для оставшихся случаев.</li>
<p></p>
<p>Первый способ нерационален, программисту в этом случае придется прописывать инструкции возврата, даже когда постановка задачи предполагает только один случай. Например:</p>

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/5a5ff4b0-be0a-49f9-9aac-483dca56992b)

<p>Здесь не предполагается, что программа будет выполнять что-то кроме тела ветвления if (1 == 1). Однако компилятор должен будет запретить компиляцию такой программы.</p>
<p>Будем далее рассматривать второй способ решения проблемы.</p>

<h2>Решение</h2>
<p>Компилятор GCC имеет несколько промежуточных представлений: AST, Gimple, RTL. </p>
<p>Нам хотелось бы, чтобы модификация не зависела от флагов оптимизаций, поэтому поправку нужно делать на начальном этапе.</p>
<p>Важным уточнением является то, что компилятор GCC на самом деле распознает нашу проблему в программе и выдает предупреждение по этому поводу:</p>

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/074788b9-6dd5-4fcd-b47f-dd5e0d671d78)

<p>Давайте разберемся, как он находит это предупреждение. Для этого рассмотрим дампы, которые GCC позволяет смотреть на различных промежуточных представлениях. 
  Здесь, заметим, что на AST представлении, в конце нашей функции foo вставляется __builtin_unreachable: </p>
  
  ![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/c215cb3d-7706-4357-8b6f-6c93ee7768f6)
<p>Вызов этой функции передает информацию остальным промежуточным представлениям о том, что в конце функции не обнаружен return, а это как раз наш случай.</p>
<p>Теперь у нас есть несколько путей развития:</p>
<li>Мы можем добавить инструкцию возврата из функции во время первой генерации __builtin_unreachable</li>
<li>Или же найти место, где обрабатывается __builtin_unreachable и выдается warning, там и добавить инструкцию возврата</li>

<h3>Пытаемся модифицировать генерацию __builtin_unreachable</h3>
<p>После тщательного поиска, обнаруживаем функцию, которая по описанию похожа на то, что мы ищем:</p>

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/0c262e51-7bf7-46cc-9a76-34c6ede8d7b2)

<p>После исследования тела функции находим место генерации нашего __builtin_unreachable</p>

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/83e7e090-7832-4659-9f79-cdc2cd1c1ced)

<p>Делаем тестовую модификацию для целочисленного типа:</p>

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/bf3ae439-4949-4c95-b58f-4cf85dc137e8)

<p>После компиляции видим, что вставка инструкции возврата работает корректно, однако есть один недочет: невозможно вывести warning, если мы делаем патч в этом месте.</p>
<p>Представим, что компилятор добавил инструкцию возврата для какой-то функции и не предупредил об этом. Тогда программист может <b>получать баги в своей программе и обнаружить их без предупреждения довольно тяжело.</b></p>
<p>
Такой случай, как минимум, должнен быть хорошо задокументирован, однако и это не защитит в полной мере от неочевидного бага.
</p>
<p>Давайте рассмотрим другой способ решения, может быть там получится выводить warning.</p>

<h3>Пытаемся модифицировать обработку __builtin_unreachable</h3>
<p>Внутри одного из проходов замечаем обработку __builtin_unreachable на Gimple представлении:</p>

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/58699f9c-ab51-4319-b99e-3dbade16ceac)

<p>Таким образом, делаем модификацию в этом месте, оставляя вывод предупреждения:</p>

![image](https://github.com/SvetoCopy/gcc_fallthrough/assets/65361271/e37e378c-223b-4157-9569-1d0cb4e86228)

<p>Добавляем также обработку флага -ftrivial-auto-var-init и получаем нашу модификацию</p>

<h2>Заключение</h2>
<p>В итоге, модификация прошла все стандартные тесты GCC, то есть патч не повлиял на работу компилятора, кроме нашего случая. Также были пройдены небольшие тесты на работоспособность патча при различных возвращаемых типах.
  Можно сказать, что решение проблемы найдено.
</p>






